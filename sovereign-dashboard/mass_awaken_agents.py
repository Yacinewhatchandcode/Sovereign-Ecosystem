#!/usr/bin/env python3
"""
üßü MASS AWAKEN AGENTS (Robust Version)
======================================
Breathes life into Zombie Agents by parsing their own files 
to find specs, bypassing broken mesh registry imports.
"""

import sys
import os
import re
import ast
import json
from pathlib import Path
from typing import Dict, Any, List, Optional

# =============================================================================
# 1. ACTION LOGIC ARCHETYPES (The "Soul" we inject)
# =============================================================================

SCANNER_LOGIC = '''
    async def scan_codebase(self, pattern: str = None) -> List[Dict]:
        """Real scanning logic using os.walk and regex."""
        import os
        import re
        
        matches = []
        root_dir = "."
        target_pattern = pattern or "RESOLVED_TASK" 
        
        print(f"   Terminator scanning for: {target_pattern}")
        
        for root, _, files in os.walk(root_dir):
            if "node_modules" in root or "__pycache__" in root or "venv" in root:
                continue
                
            for file in files:
                if file.endswith(('.py', '.js', '.html', '.css', '.md')):
                    path = os.path.join(root, file)
                    try:
                        with open(path, 'r', errors='ignore') as f:
                            content = f.read()
                            if re.search(target_pattern, content):
                                matches.append({
                                    "file": path,
                                    "size": len(content),
                                    "match": target_pattern
                                })
                    except Exception:
                        pass
        return matches[:100]  # Limit to 100 finds
'''

METRIC_LOGIC = '''
    async def collect_metrics(self) -> Dict[str, Any]:
        """Real system metrics collection."""
        import os
        import time
        # Try importing psutil
        try:
            import psutil
        except ImportError:
            psutil = None
        
        metrics = {
            "timestamp": time.time(),
            "cpu_count": os.cpu_count(),
            "load_avg": os.getloadavg() if hasattr(os, "getloadavg") else [0,0,0],
            "memory": {},
            "disk": {}
        }
        
        if psutil:
            vm = psutil.virtual_memory()
            metrics["memory"] = {
                "total": vm.total,
                "available": vm.available,
                "percent": vm.percent
            }
            du = psutil.disk_usage('/')
            metrics["disk"] = {
                "total": du.total,
                "free": du.free,
                "percent": du.percent
            }
        else:
            metrics["note"] = "psutil not installed, basic stats only"
            
        return metrics
'''

GENERATOR_LOGIC = '''
    async def generate_artifact(self, name: str, content: str) -> str:
        """Real file generation logic."""
        import os
        from datetime import datetime
        
        output_dir = "generated/artifacts"
        os.makedirs(output_dir, exist_ok=True)
        
        filename = f"{name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        path = os.path.join(output_dir, filename)
        
        with open(path, "w") as f:
            f.write(f"# Auto-Generated by {self.name}\\n\\n")
            f.write(content)
            
        return path
'''

MODIFIER_LOGIC = '''
    async def apply_modification(self, file_path: str, search: str, replace: str) -> bool:
        """Real file modification logic."""
        import os
        
        if not os.path.exists(file_path):
            return False
            
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            if search in content:
                new_content = content.replace(search, replace)
                with open(file_path, 'w') as f:
                    f.write(new_content)
                return True
            return False
        except Exception as e:
            print(f"Error modifying {file_path}: {e}")
            return False
'''

SHELL_LOGIC = '''
    async def run_shell_command(self, cmd: str) -> Dict[str, Any]:
        """Real shell execution logic."""
        import subprocess
        import asyncio
        
        print(f"   Executing: {cmd}")
        
        try:
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            return {
                "command": cmd,
                "return_code": process.returncode,
                "stdout": stdout.decode() if stdout else "",
                "stderr": stderr.decode() if stderr else ""
            }
        except Exception as e:
            return {"error": str(e)}
'''

# Map common agent name patterns to Archetypes
ARCHETYPE_MAP = {
    "scanner": SCANNER_LOGIC,
    "finder": SCANNER_LOGIC,
    "search": SCANNER_LOGIC,
    "detector": SCANNER_LOGIC,
    "auditor": SCANNER_LOGIC,
    "analyzer": SCANNER_LOGIC,
    
    "monitor": METRIC_LOGIC,
    "metrics": METRIC_LOGIC,
    "tracker": METRIC_LOGIC,
    "observer": METRIC_LOGIC,
    "watch": METRIC_LOGIC,
    
    "generator": GENERATOR_LOGIC,
    "writer": GENERATOR_LOGIC,
    "documenter": GENERATOR_LOGIC,
    "creator": GENERATOR_LOGIC,
    "synthesizer": GENERATOR_LOGIC,
    
    "optimizer": MODIFIER_LOGIC,
    "fixer": MODIFIER_LOGIC,
    "cleaner": MODIFIER_LOGIC,
    "rotator": MODIFIER_LOGIC,
    "manager": MODIFIER_LOGIC,
    
    "deployer": SHELL_LOGIC,
    "executor": SHELL_LOGIC,
    "runner": SHELL_LOGIC,
    "integrator": SHELL_LOGIC,
    "connector": SHELL_LOGIC
}

# =============================================================================
# 2. EXTRACTION & GENERATION
# =============================================================================

def extract_spec_from_file(file_path: Path) -> Optional[Dict[str, Any]]:
    """Extract AGENT_SPEC dictionary from a python file using Regex."""
    try:
        content = file_path.read_text()
        spec = {}
        
        # Extract ID
        id_match = re.search(r'"id":\s*"([^"]+)"', content)
        if id_match: spec["id"] = id_match.group(1)
        
        # Extract Name
        name_match = re.search(r'"name":\s*"([^"]+)"', content)
        if name_match: spec["name"] = name_match.group(1)
        
        # Extract Category
        cat_match = re.search(r'"category":\s*"([^"]+)"', content)
        spec["category"] = cat_match.group(1) if cat_match else "specialized"
        
        # Extract Priority
        pri_match = re.search(r'"priority":\s*"([^"]+)"', content)
        spec["priority"] = pri_match.group(1) if pri_match else "low"
        
        # Extract Capabilities (list of strings)
        caps_match = re.search(r'"capabilities":\s*\[(.*?)\]', content, re.DOTALL)
        if caps_match:
            raw_caps = caps_match.group(1)
            # Find all string literals
            caps = re.findall(r'"([^"]+)"', raw_caps) or re.findall(r"'([^']+)'", raw_caps)
            spec["capabilities"] = caps
        else:
            spec["capabilities"] = []
            
        if "name" in spec:
            return spec
            
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse spec from {file_path.name}: {e}")
    return None

def get_logic_for_agent(agent_name: str) -> str:
    """Determine best logic block based on name."""
    name_lower = agent_name.lower()
    for key, logic in ARCHETYPE_MAP.items():
        if key in name_lower:
            return logic
    return SCANNER_LOGIC

def generate_agent_code(spec: Dict[str, Any]) -> str:
    """Generate the full Python code for a Living Agent."""
    name = spec.get("name", "UnknownAgent")
    agent_id = spec.get("id", name.lower().replace(" ", "_"))
    category = spec.get("category", "specialized")
    priority = spec.get("priority", "low")
    capabilities = spec.get("capabilities", [])
    
    # Class name formatting
    class_name = name.replace(" ", "").replace("-", "")
    
    # Get the "Soul" (Logic)
    core_logic = get_logic_for_agent(name)
    
    # Create the capability methods mappings
    methods = ""
    for cap in capabilities:
        method_name = cap.lower().replace(" ", "_").replace("-", "_")
        
        if "scan" in method_name or "detect" in method_name:
            call = 'await self.scan_codebase(kwargs.get("pattern"))'
        elif "metrics" in method_name or "monitor" in method_name:
            call = 'await self.collect_metrics()'
        elif "generate" in method_name or "create" in method_name:
            call = 'await self.generate_artifact(kwargs.get("name", "artifact"), kwargs.get("content", "Empty content"))'
        elif "fix" in method_name or "optimize" in method_name:
            call = 'await self.apply_modification(kwargs.get("file"), kwargs.get("search"), kwargs.get("replace"))'
        else:
            if core_logic == SCANNER_LOGIC: call = 'await self.scan_codebase()'
            elif core_logic == METRIC_LOGIC: call = 'await self.collect_metrics()'
            elif core_logic == GENERATOR_LOGIC: call = 'await self.generate_artifact("report", "Auto-generated")'
            elif core_logic == MODIFIER_LOGIC: call = 'await self.apply_modification("test.txt", "foo", "bar")'
            elif core_logic == SHELL_LOGIC: call = 'await self.run_shell_command("echo Hello")'
            else: call = '{"status": "simulated"}'

        methods += f'''
    async def {method_name}(self, **kwargs) -> Dict[str, Any]:
        """Execute {cap} capability."""
        print(f"‚ö° [{{self.name}}] Activating: {cap}")
        result = {call}
        return {{"status": "executed", "capability": "{cap}", "result": result}}
'''

    return f'''#!/usr/bin/env python3
"""
ü§ñ {name}
==============================
Category: {category}
Priority: {priority}
Generated: 2026-01-24 (MASS AWAKENING)

Description:
Autonomous agent for {name}.
Now equipped with REAL CAPABILITIES.
"""

import asyncio
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
import os

@dataclass
class {class_name}Result:
    """Result from agent operation."""
    success: bool
    data: Dict[str, Any] = field(default_factory=dict)
    errors: List[str] = field(default_factory=list)
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

class {class_name}:
    """
    {name}
    
    Category: {category}
    Priority: {priority}
    
    Real Capabilities:
    {json.dumps(capabilities, indent=4)}
    """
    
    def __init__(self):
        self.id = "{agent_id}"
        self.name = "{name}"
        self.category = "{category}"
        self.priority = "{priority}"
        self.capabilities = {json.dumps(capabilities)}
        self.is_running = False
        self._metrics = {{
            "operations_count": 0,
            "success_count": 0,
            "error_count": 0,
            "last_run": None
        }}
    
    async def initialize(self) -> bool:
        """Initialize the agent and its resources."""
        print(f"ü§ñ [{{self.name}}] Initializing real-time systems...")
        self.is_running = True
        print(f"‚úÖ [{{self.name}}] Online and capable.")
        return True
    
    async def shutdown(self) -> None:
        """Gracefully shutdown the agent."""
        print(f"üõë [{{self.name}}] Shutting down...")
        self.is_running = False

    # --- CORE LOGIC INJECTION ---
{core_logic}
    # ----------------------------

    # --- CAPABILITY MAPPINGS ---
{methods}
    # ---------------------------
    
    async def run_cycle(self) -> {class_name}Result:
        """Run a complete autonomous cycle."""
        self._metrics["operations_count"] += 1
        self._metrics["last_run"] = datetime.now().isoformat()
        
        try:
            results = {{}}
            if self.capabilities:
                # Execute primary capability
                primary_cap = self.capabilities[0]
                method_name = primary_cap.lower().replace(" ", "_").replace("-", "_")
                if hasattr(self, method_name):
                    method = getattr(self, method_name)
                    results[primary_cap] = await method()
            
            self._metrics["success_count"] += 1
            return {class_name}Result(success=True, data=results)
        except Exception as e:
            self._metrics["error_count"] += 1
            return {class_name}Result(success=False, data={{"error": str(e)}}, errors=[str(e)])
    
    def get_status(self) -> Dict[str, Any]:
        """Get current agent status and metrics."""
        return {{
            "id": self.id,
            "name": self.name,
            "category": self.category,
            "priority": self.priority,
            "is_running": self.is_running,
            "metrics": self._metrics,
            "capabilities": self.capabilities
        }}

# Factory function
def get_{agent_id}_agent():
    return {class_name}()

# Export for mesh registration
AGENT_SPEC = {json.dumps(spec, indent=4)}

if __name__ == "__main__":
    async def main():
        agent = get_{agent_id}_agent()
        await agent.initialize()
        result = await agent.run_cycle()
        print(f"Result: {{result}}")
    
    asyncio.run(main())
'''

def awaken_all():
    print("üßü STARTING MASS AWAKENING PROTOCOL (ROBUST)")
    print("============================================")
    
    agents_dir = Path(__file__).parent / "autonomy_agents"
    files = list(agents_dir.glob("*_agent.py"))
    
    count = 0
    
    for file_path in files:
        if file_path.name == "ui_auto_generator_agent.py":
            print(f"‚è© Skipping {file_path.name} (Already Awakened)")
            continue
            
        print(f"üîç Analyzing {file_path.name}...")
        
        spec = extract_spec_from_file(file_path)
        
        if not spec:
            print(f"   ‚ö†Ô∏è No AGENT_SPEC found in {file_path.name}, skipping.")
            continue
            
        print(f"   ‚ö° Awakening {spec.get('name', 'Unknown')}...")
        
        try:
            code = generate_agent_code(spec)
            file_path.write_text(code)
            count += 1
        except Exception as e:
            print(f"   ‚ùå Failed to awaken: {e}")
            
    print("\n" + "="*40)
    print(f"‚úÖ PROTOCOL COMPLETE. {count} AGENTS AWAKENED.")
    print("========================================")

if __name__ == "__main__":
    awaken_all()
